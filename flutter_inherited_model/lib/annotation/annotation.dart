/// {@template flutter_inherited_model.flutter_inherited_model}
/// An annotation that designates a model class to be generated as an `InheritedModel` widget.
///
/// A class with this annotation will have code automatically generated by `build_runner`
/// for a widget that inherits from `InheritedModel` and for related state management.
///
/// Example:
/// ```dart
/// @FlutterInheritedModel(name: 'MyDataModel')
/// class MyModel with $MyModel {
///   MyModel._();
///
///   factory MyModel() = _$MyModel;
///   // ...
/// }
/// ```
/// {@endtemplate}
final class FlutterInheritedModel {
  /// {@template flutter_inherited_model.flutter_inherited_model.name}
  /// Specifies the name of the `InheritedModel` widget to be generated.
  ///
  /// If not specified, the name of the model class will be used.
  /// For example, the `MyModel` class will become `MyModelInheritedModel`.
  /// {@endtemplate}
  final String? name;

  /// {@template flutter_inherited_model.flutter_inherited_model.useLifecycleState}
  /// Determines whether the model should receive widget app lifecycle events.
  ///
  /// If set to `true`, you can override app lifecycle callback methods such as `onDidChangeAppLifecycleState` within the model class to implement
  /// logic for state initialization, resource disposal, etc.
  /// {@endtemplate}
  final bool useLifecycleState;

  /// {@template flutter_inherited_model.flutter_inherited_model.useAsyncWorker}
  /// Determines whether to use `AsyncWorker` for safely handling asynchronous tasks within the model.
  ///
  /// If set to `true`, the `asyncWorker` object can be used to prevent asynchronous callbacks
  /// from being executed after the widget has been disposed.
  /// {@endtemplate}
  final bool useAsyncWorker;

  /// {@template flutter_inherited_model.flutter_inherited_model.useSingleTickerProvider}
  /// Determines whether to add `SingleTickerProviderStateMixin` to the widget.
  ///
  /// Set to `true` if a single `Ticker` is required, such as for an `AnimationController`.
  /// {@endtemplate}
  final bool useSingleTickerProvider;

  /// {@template flutter_inherited_model.flutter_inherited_model.useTickerProvider}
  /// Determines whether to add `TickerProviderStateMixin` to the widget.
  ///
  /// Set to `true` if multiple `Ticker`s are required, such as for multiple `AnimationController`s.
  /// Cannot be set to `true` at the same time as `useSingleTickerProvider`.
  /// {@endtemplate}
  final bool useTickerProvider;

  /// {@template flutter_inherited_model.flutter_inherited_model.event}
  /// Specifies the `Event` type to use for handling one-way events between the model and the UI.
  ///
  /// The specified `Event` class (usually defined as a `sealed class`) can be used to trigger
  /// UI interactions from the model, such as showing a SnackBar or navigating to a new page.
  /// {@endtemplate}
  final Type? event;

  /// {@macro flutter_inherited_model.flutter_inherited_model}
  const FlutterInheritedModel({
    this.name,
    this.useLifecycleState = false,
    this.useAsyncWorker = false,
    this.useSingleTickerProvider = false,
    this.useTickerProvider = false,
    this.event,
  });
}

/// {@template flutter_inherited_model.flutter_inherited_state}
/// An annotation used to define a sub-state within a model class.
///
/// It allows for the separation of complex model states and logic into multiple smaller
/// state classes, improving code readability and maintainability.
///
/// Example:
/// ```dart
/// @FlutterInheritedState()
/// class UserProfileState with _$UserProfileState {
///   UserProfileState._();
///
///   factory UserProfileState() = _$UserProfileState;
///
///   @inheritedModelState
///   late String name;
/// }
///
/// @FlutterInheritedModel()
/// class MyModel with _$MyModel {
///   final userProfile = UserProfileState();
/// }
/// ```
/// {@endtemplate}
final class FlutterInheritedState {
  /// {@template flutter_inherited_model.flutter_inherited_state.name}
  /// Specifies the name of the sub-state class to be generated.
  ///
  /// Generally, this does not need to be specified, as `build_runner` manages the name automatically.
  /// {@endtemplate}
  final String? name;

  /// {@template flutter_inherited_model.flutter_inherited_state.useAsyncWorker}
  /// Determines whether to use `AsyncWorker` for safely handling asynchronous tasks within the sub-state class.
  ///
  /// If set to `true`, the `asyncWorker` object can be used to prevent asynchronous callbacks
  /// from being executed after the widget has been disposed.
  /// {@endtemplate}
  final bool useAsyncWorker;

  /// {@macro flutter_inherited_model.flutter_inherited_state}
  const FlutterInheritedState({this.name, this.useAsyncWorker = false});
}

/// {@template flutter_inherited_model.inherited_model_state}
/// An annotation that designates a state field to be managed by the `InheritedModel`.
///
/// Fields with this annotation will have logic automatically generated by `build_runner`
/// to detect state changes and rebuild only the widgets that depend on that state.
///
/// Example:
/// ```dart
/// @inheritedModelState
/// int counter;
/// ```
/// {@endtemplate}
final class InheritedModelState {
  /// {@macro flutter_inherited_model.inherited_model_state}
  const InheritedModelState();
}

/// {@macro flutter_inherited_model.inherited_model_state}
const inheritedModelState = InheritedModelState();
